import { NextPage } from "next";
import Head from "next/head";
import Script from "next/script";
import styles from '../styles/Home.module.css';
import { useEffect, useState } from "react";
import { Forecast, optionsFetch, typeErrorCallback, typeSuccessCallback, typeSelected, dataGeo, dataGeoErr } from "../components/interface";
import { ModelForecast } from "../components/modelForecast";
import { Loading } from "../components/load";
import { ErrorPage } from "../components/denypermission";

const options:optionsFetch = {
    enableHighAccuracy: true,
    timeout: 5000,
    maximumAge: 0,
};

const Forecast: NextPage = () =>{
    const [geolocation, setGeolocation] = useState<dataGeo>({
        latitudeFromAPI: 0,
        longitudeFromAPI: 0
    });
    const [geolocationErr, setGeolocationErr] = useState<dataGeoErr>({
        codeFromAPI: 0,
        messageFromAPI: ""
    });
    const [dataForecast, setDataForecast] = useState<Forecast>();
    const [loading, setLoading] = useState<boolean>(true);
    const [selected, setSelected] = useState<typeSelected>({
        mode: "",
        lenguage: "en",
        degrees: "metric"
    });

    async function GetDataWeatherForecast(abortController:AbortController):Promise<void> {
        try{
            setLoading(true);
            let url:RequestInfo = `https://api.openweathermap.org/data/2.5/forecast?lat=${geolocation.latitudeFromAPI}&lon=${geolocation.longitudeFromAPI}&appid=f407aaedf1c4eafa4138ef2dd93cb636&lang=${selected.lenguage}&units=${selected.degrees}`;
            const response:Response = await fetch(url, {
                signal: abortController.signal,
            });

            if(!response.ok){
                setGeolocationErr({codeFromAPI: response.status, messageFromAPI: response.statusText});
                const message = `An error has occured: ${response.status} -- ${response.statusText}`;
                throw new Error(message);
            };

            const json:Forecast = await response.json();
            setDataForecast(json);
        }catch(err){
            setGeolocationErr({codeFromAPI: 500, messageFromAPI: "Failed to fetch::ERR_NOT_RESOLVED."});
            console.error(err);
        }finally{
            setLoading(false);
        };
    };

    const successCallback = (position:typeSuccessCallback):void => {
        const { latitude, longitude } = position.coords;
        setGeolocation({latitudeFromAPI: latitude, longitudeFromAPI: longitude});
    };
      
    const errorCallback = (error:typeErrorCallback):void => {
        console.error(error);
        setGeolocationErr({codeFromAPI:error.code, messageFromAPI:error.message});
    };

    useEffect(()=>{
        if(navigator.geolocation){
            navigator.geolocation.getCurrentPosition(successCallback, errorCallback, options);
        }else{
            setGeolocationErr({codeFromAPI: 101, messageFromAPI:"This browser have not suppoted for this application"});
        }; 

        const abortController:AbortController = new AbortController();
        setTimeout(() => abortController.abort(), 8000);

        GetDataWeatherForecast(abortController);
    },[selected]);

    return(
    <div className={styles.container}>
        <Head>
            <title>Weather App-Forecast</title>
            <meta name="description" content="Generated by create next app" />
            <link rel="icon" href="/favicon.ico" />
        </Head>
    
        <main className={styles.main}>
            {dataForecast !== undefined && !loading && geolocationErr.messageFromAPI === "" && 
                dataForecast.list.map(el => <ModelForecast key={el.dt} weatherForecast={el} selected={selected} setSelected={setSelected} />)
            }
            {loading &&
                <Loading message="Catching All data..." width={40} height={20}/>
            }
            {geolocationErr.messageFromAPI !== "" &&
                <ErrorPage geolocationErr={geolocationErr} />
            }
        </main>
        <Script src="https://cdn.tailwindcss.com" defer />
    </div>
    );
};

export default Forecast;